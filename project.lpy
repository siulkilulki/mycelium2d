import math

#H-head, turns into TH if there is space(???), else T
#T-tail, normally doesn't change, can sometimes create branch
width = 0.5
length = 0.5
segments = [] #line segments ((x1,y1), (x2, y2)) <--- position of segment,

#starting values
position = (0,0) 
heading = (0,1)
position = (0,1)

min_dist = 4
def getDistance(x1,y1,x2,y2):
  return math.sqrt(((x1-x2)**2)+((y1-y2)**2)) #(~-180, 180)
  
  #!!! probably casting to floats is needed
  
def getAngle(x1,y1,x2,y2):
  #x1,y1 start
  return  math.degrees(math.atan2((x2-x1),(y2-y1)))
  
def rotate(x,y,xd,yd):
  #xd,yd heading direction, probably from ?H
  turn_right=0
  turn_left=0
  for (a,b) in positions:
    if getDistance(x,y,a,b)<min_dist:
      glob_angle=getAngle(x,y,a,b)
      direction=math.degrees(math.atan2(xd,yd))
      angle=glob_angle-direction#check for extreme values    !!!
      if angle>=0:
        if angle>110:
          pass# not important what's behind
        elif angle<=10:
          turn_left=max(turn_left,30)
        elif angle>10 and angle<=45:
          turn_left=max(turn_left,15)
        elif angle>45 and angle<=110:
          turn_left=max(turn_left,5)
      else:
        if angle<-110:
          pass# not important what's behind
        elif angle>=-10:
          turn_right=max(turn_right,30)
        elif angle<-10 and angle>=-45:
          turn_right=max(turn_right,15)
        elif angle<-45 and angle>=-110:
          turn_right=max(turn_right,5)
       
  #todo: add if turn_left ==0 of right==0, then turn, if both <>0 then look what's ahead and if blocked return something like(0,true) (rotation, stop)

def ccw(A,B,C):
  return (C[1]-A[1]) * (B[0]-A[0]) > (B[1]-A[1]) * (C[0]-A[0])

# Return true if line segments AB and CD intersect
def intersect(A,B,C,D):
  return ccw(A,C,D) != ccw(B,C,D) and ccw(A,B,C) != ccw(A,B,D) 

def intersect_any(new_segment):
    for segment in reversed(segments):
      if intersect(new_segment[0], new_segment[1], segment[0], segment[1]):
        return True
    return False


Axiom: _(width) H

derivation length: 10
production:
?P(z,x,y, type_) : # we have y mapped to x, z mapped to y 
  global position
  if type_ == 0:
    position = (x,y)
  else: 
    segments.append((position, (x,y)))
    print(segments)
    produce
    
?H(z,x,y):
  heading = (x,y)
  print('heading: {}'.format((x,y)))
  produce

H:
  print("H")
  next_position = position + heading #
  if not intersect_any((position, next_position)):
    produce T ?P(0,0,0,0) ?H(0,0,0) H ?P(0,0,0,1)
  else:
    produce


interpretation:
H: produce SetColor(1) F(length,width)
T: produce SetColor(2) F(length,width)

endlsystem
